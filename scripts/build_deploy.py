#!/usr/bin/env python3
"""
Build deployment-ready artefacts from repo sources.

Generates:
  deploy/sem_*.yaml         — semantic view YAMLs with custom_instructions injected
  deploy/deploy_agent.sql   — agent SQL with assembled instructions baked in

Usage:
  python scripts/build_deploy.py            # writes to deploy/
  python scripts/build_deploy.py --out-dir dist/deploy

This script is designed to run in CI (GitHub Actions) so that deploy.sql
can reference the generated YAMLs directly from the Git stage.
"""
from __future__ import annotations

import argparse
import sys
from pathlib import Path

# ---------------------------------------------------------------------------
# Bootstrap
# ---------------------------------------------------------------------------
_SCRIPT_DIR = Path(__file__).resolve().parent
_REPO_ROOT = _SCRIPT_DIR.parent

if str(_SCRIPT_DIR) not in sys.path:
    sys.path.insert(0, str(_SCRIPT_DIR))

from semantic_diff.assemble import (
    assemble_semantic_view_instructions,
    assemble_agent_instructions,
)

# Reuse deployer's YAML builder (it injects custom_instructions properly)
sys.path.insert(0, str(_REPO_ROOT / "app"))
from deployer import build_deployable_yaml  # noqa: E402

from semantic_diff.constants import SCHEMA_FQN, AGENT_FQN, SEMANTIC_VIEW_NAMES

VIEWS = SEMANTIC_VIEW_NAMES


# ---------------------------------------------------------------------------
# Build functions
# ---------------------------------------------------------------------------

def build_semantic_view_yamls(out_dir: Path) -> list[Path]:
    """Assemble instructions and inject into semantic view YAMLs."""
    assembled = assemble_semantic_view_instructions(_REPO_ROOT)
    paths: list[Path] = []

    for view_name in VIEWS:
        ci = assembled.get(view_name, {})
        yaml_text = build_deployable_yaml(view_name, ci)

        out_path = out_dir / f"{view_name.lower()}.yaml"
        out_path.write_text(yaml_text, encoding="utf-8")
        paths.append(out_path)
        print(f"  {out_path}")

    return paths


def build_agent_sql(out_dir: Path) -> Path:
    """Generate deploy_agent.sql with assembled instruction text."""
    assembled = assemble_agent_instructions(_REPO_ROOT)
    agent = assembled.get("INSULINTEL", {})

    orchestration = agent.get("orchestration_instructions", "")
    response = agent.get("response_instructions", "")

    sql = f"""\
-- =============================================================================
-- DEPLOY CORTEX AGENT — AUTO-GENERATED
-- =============================================================================
-- Generated by: python scripts/build_deploy.py
-- Do NOT edit manually — edit instruction modules under instructions/
-- =============================================================================

-- Step 1: Fetch latest repo contents
ALTER GIT REPOSITORY {SCHEMA_FQN}.REPO_SEMANTIC_MODELS FETCH;

-- Step 2: Update orchestration instructions
ALTER CORTEX AGENT {AGENT_FQN}
SET ORCHESTRATION_INSTRUCTIONS = $${orchestration}$$;

-- Step 3: Update response instructions
ALTER CORTEX AGENT {AGENT_FQN}
SET RESPONSE_INSTRUCTIONS = $${response}$$;

-- Step 4: Verify
DESCRIBE CORTEX AGENT {AGENT_FQN};
"""

    out_path = out_dir / "deploy_agent.sql"
    out_path.write_text(sql, encoding="utf-8")
    print(f"  {out_path}")
    return out_path


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main() -> int:
    parser = argparse.ArgumentParser(
        description="Build deployment-ready artefacts from repo sources.",
    )
    parser.add_argument(
        "--out-dir", default="deploy",
        help="Output directory (default: deploy/)",
    )
    args = parser.parse_args()

    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    print("Building semantic view YAMLs...")
    build_semantic_view_yamls(out_dir)

    print("Building agent SQL...")
    build_agent_sql(out_dir)

    print(f"\nDone. Artefacts written to {out_dir}/")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
