#!/usr/bin/env python3
"""
Build deployment-ready artefacts from repo sources.

Generates:
  deploy/sem_*.yaml         — semantic view YAMLs with custom_instructions injected
  deploy/deploy_agent.sql   — agent SQL with assembled instructions baked in

Usage:
  python scripts/build_deploy.py            # writes to deploy/
  python scripts/build_deploy.py --out-dir dist/deploy

This script is designed to run in CI (GitHub Actions) so that deploy.sql
can reference the generated YAMLs directly from the Git stage.
"""
from __future__ import annotations

import argparse
import sys
from pathlib import Path

# ---------------------------------------------------------------------------
# Bootstrap
# ---------------------------------------------------------------------------
_SCRIPT_DIR = Path(__file__).resolve().parent
_REPO_ROOT = _SCRIPT_DIR.parent

if str(_SCRIPT_DIR) not in sys.path:
    sys.path.insert(0, str(_SCRIPT_DIR))

from semantic_diff.assemble import (
    assemble_semantic_view_instructions,
    assemble_agent_instructions,
)

# Reuse deployer's YAML builder (it injects custom_instructions properly)
sys.path.insert(0, str(_REPO_ROOT / "app"))
from deployer import build_deployable_yaml  # noqa: E402

from semantic_diff.constants import SCHEMA_FQN, AGENT_FQN, SEMANTIC_VIEW_NAMES

VIEWS = SEMANTIC_VIEW_NAMES


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _indent(text: str, spaces: int) -> str:
    """Indent every line of *text* by *spaces* spaces."""
    prefix = " " * spaces
    return "\n".join(prefix + line for line in text.splitlines())


# ---------------------------------------------------------------------------
# Build functions
# ---------------------------------------------------------------------------

def build_semantic_view_yamls(out_dir: Path) -> list[Path]:
    """Build clean semantic view YAMLs (no custom_instructions — they
    are set separately via SQL AI clauses)."""
    paths: list[Path] = []

    for view_name in VIEWS:
        yaml_text = build_deployable_yaml(view_name)

        out_path = out_dir / f"{view_name.lower()}.yaml"
        out_path.write_text(yaml_text, encoding="utf-8")
        paths.append(out_path)
        print(f"  {out_path}")

    return paths


def _escape_sql_string(text: str) -> str:
    """Escape single quotes for safe embedding in SQL literal strings."""
    return text.replace("'", "''")


def build_custom_instructions_sql(out_dir: Path) -> Path:
    """Generate SQL to set AI_SQL_GENERATION / AI_QUESTION_CATEGORIZATION
    on each semantic view via CREATE OR REPLACE with COPY GRANTS.

    Because ALTER SEMANTIC VIEW doesn't support AI instruction clauses,
    we use GET_DDL as a template — but at build time we don't have a live
    connection.  Instead we generate an idempotent block that fetches,
    modifies, and re-creates each view.
    """
    assembled = assemble_semantic_view_instructions(_REPO_ROOT)
    blocks: list[str] = []

    for view_name in VIEWS:
        ci = assembled.get(view_name, {})
        sg = ci.get("sql_generation", "").strip()
        qc = ci.get("question_categorization", "").strip()
        if not sg and not qc:
            continue

        fqn = f"{SCHEMA_FQN}.{view_name}"
        parts = [f"-- {view_name}: set AI custom instructions"]
        parts.append(f"-- Step 1: get current DDL")
        parts.append(f"SET DDL = (SELECT GET_DDL('SEMANTIC_VIEW', '{fqn}', TRUE));")
        parts.append("")

        ai_clause = ""
        if sg:
            ai_clause += f"\n  AI_SQL_GENERATION '{_escape_sql_string(sg)}'"
        if qc:
            ai_clause += f"\n  AI_QUESTION_CATEGORIZATION '{_escape_sql_string(qc)}'"

        parts.append(f"-- Step 2: recreate with AI instructions + COPY GRANTS")
        parts.append(
            f"EXECUTE IMMEDIATE "
            f"REPLACE(RTRIM(RTRIM($DDL), ';'), "
            f"'create or replace semantic view', "
            f"'create or replace semantic view') "
            f"|| '{ai_clause}\\n  COPY GRANTS;';"
        )
        blocks.append("\n".join(parts))

    sql = f"""\
-- =============================================================================
-- SET AI CUSTOM INSTRUCTIONS ON SEMANTIC VIEWS — AUTO-GENERATED
-- =============================================================================
-- Generated by: python scripts/build_deploy.py
-- Do NOT edit manually — edit instruction modules under instructions/
--
-- Snowflake Semantic Views set custom instructions via AI_SQL_GENERATION and
-- AI_QUESTION_CATEGORIZATION clauses on CREATE SEMANTIC VIEW (not in YAML).
-- =============================================================================

{"\\n\\n".join(blocks) if blocks else "-- No custom instructions to set."}
"""
    out_path = out_dir / "set_custom_instructions.sql"
    out_path.write_text(sql, encoding="utf-8")
    print(f"  {out_path}")
    return out_path


def build_agent_sql(out_dir: Path) -> Path:
    """Generate deploy_agent.sql with assembled instruction text."""
    assembled = assemble_agent_instructions(_REPO_ROOT)
    agent = assembled.get("INSULINTEL", {})

    orchestration = agent.get("orchestration_instructions", "")
    response = agent.get("response_instructions", "")

    sql = f"""\
-- =============================================================================
-- DEPLOY CORTEX AGENT — AUTO-GENERATED
-- =============================================================================
-- Generated by: python scripts/build_deploy.py
-- Do NOT edit manually — edit instruction modules under instructions/
-- =============================================================================

-- Step 1: Fetch latest repo contents
ALTER GIT REPOSITORY {SCHEMA_FQN}.REPO_SEMANTIC_MODELS FETCH;

-- Step 2: Update agent instructions (full specification replacement)
ALTER AGENT {AGENT_FQN}
MODIFY LIVE VERSION SET SPECIFICATION = $$
instructions:
  orchestration: |
{_indent(orchestration, 4)}
  response: |
{_indent(response, 4)}
$$;

-- Step 3: Verify
DESCRIBE AGENT {AGENT_FQN};
"""

    out_path = out_dir / "deploy_agent.sql"
    out_path.write_text(sql, encoding="utf-8")
    print(f"  {out_path}")
    return out_path


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main() -> int:
    parser = argparse.ArgumentParser(
        description="Build deployment-ready artefacts from repo sources.",
    )
    parser.add_argument(
        "--out-dir", default="deploy",
        help="Output directory (default: deploy/)",
    )
    args = parser.parse_args()

    out_dir = Path(args.out_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    print("Building semantic view YAMLs...")
    build_semantic_view_yamls(out_dir)

    print("Building custom instructions SQL...")
    build_custom_instructions_sql(out_dir)

    print("Building agent SQL...")
    build_agent_sql(out_dir)

    print(f"\nDone. Artefacts written to {out_dir}/")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
